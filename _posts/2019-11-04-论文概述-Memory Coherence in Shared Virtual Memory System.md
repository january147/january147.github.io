---
tags:
 - paper summary
 - distributed system
---



&emsp;&emsp;该论文简要介绍了松散耦合的多处理平台虚拟内存机制，就其中最主要的的保证虚拟内存一致性的问题提出了多种算法，并对这些算法进行的分析和测试，证实松散耦合的多处理平台中的虚拟内存一致性问题可以被有效解决。

&emsp;&emsp;论文首先讨论了处理虚拟内存一致性的两个关键问题，即内存单元粒度大小问题和保证一致性的基本机制问题。针对第一个问题，论文提出采用传统内存分页机制中的页为一致性管理的基本单元较为合适。针对第二个问题，论文将其分为两个子问题，即内存单元同步机制问题和内存单元所有者管理策略问题。对于内存单元同步机制，论文介绍了两种机制，即“失效”机制和“写回”机制。关于这两种机制，论文指出，“写回”机制性能开销过大，因此采用“失效(Invalidation)”机制更合适，可以达到较高的性能。对于内存单元所有者管理策略，论文将其按照两个方面划分，即静态（内存页所有者固定）和动态（由最后一个对某内存页执行写操作的处理器做该内存页的所有者），中心化（单管理者）和分布式（多管理者），并指出指定静态地划分内存单元所有者的策略不合适，会造成较高的性能开销。因此论文只对动态中心化和动态分布式的管理方式进行研究。

&emsp;&emsp;按照前面部分讨论的方案，论文提出并分析了一共7种处理内存一致性算法。以下提到的管理者，所有者和申请者都是指某个处理器。

&emsp;&emsp;第一种算法是完全中心化的管理算法，由运行在一个处理器上的管理者管理内存页所有者信息，内存页复制信息，并处理所有读写内存页的请求。该算法要求管理者维护申请某一内存页的申请者队列（即由管理者在某个申请者对某页内存的操作未完成前阻塞其他申请该内存页的申请者），因而要求申请者在完成操作后向管理者发送确认消息，因此管理者很可能成为性能瓶颈。

&emsp;&emsp;第二种算法仍然是中心化的管理算法，由运行在一个处理器上的管理者管理内存页所有者信息，但不再管理内存页复制信息。管理者仅仅转发请求给内存页所有者，不再维护申请某一内存页的申请者队列，因此由各个内存页所有者维护申请该一内存页的申请者队列并记录内存页复制信息。

&emsp;&emsp;第三种算法是固定的多管理者算法，每个处理器上有一个管理者，每个管理者管理固定的一部分内存页，管理者和内存页的对应规则可以通过一个固定的映射函数实现。每个申请者向对应的内存页管理者发送申请，每个管理者的处理流程同第二种算法一致。

&emsp;&emsp;第四种算法是广播式的多管理者算法，该算法中由内存页的所有者作为内存页的管理者，请求者将内存页请求广播给所有管理者，由被请求内存页所有者收到请求后进行响应。

&emsp;&emsp;第五种算法是动态的多管理者算法，但论文中描述的算法似乎不正确，存在死循环转发。该算法中仍然由由内存页的所有者作为内存页的管理者。每个申请者记录内存页可能的所有者，在需要申请某个内存页时，向可能的所有者发送请求，接收到请求的处理器如果是真正的所有者则进行响应，否则将请求转发给自己记录的该内存页的可能的所有者，经过至多两次转发，该请求就会达到真正的所有者，并由所有者进行响应。该方案避免了每个请求都需要广播，提高了性能。

&emsp;&emsp;第六种算法是对第五种算法的一点改进，但还是论文中描述的算法仍然有第五种算法的问题，存在死循环转发。在第五种算法中，如果一个内存页的所有者发生了改变，其他还未访问过该内存页的处理器对该内存页的访问就需要经过转发，增加了性能开销。因此在第六种算法中，某内存页发生一定缺页错误次数后就进行广播一次该内存页的真正所有者，减少转发次数。

&emsp;&emsp;第七种算法对内存页副本信息的保存进行了优化，以内存页所有者为树根，采用树状结构来保存持有内存页副本的处理器，此外，使用树状结构记录内存页副本持有者使得读取的内存页的缺页请求可以被任何拥有该内存页副本的处理器处理，而不需要转发给该内存页真正的所有者，提高了性能。

&emsp;&emsp;论文的实验部分首先对对第二种算法（改进的中心化管理算法）和第五种算法（动态多管理者算法）进行了对比测试，测试显示第五种算法的转发请求数量显著小于第二种算法，性能显著提高。之后利用不同的程序如计算PDE程序，归并排序程序，矩阵乘法程序对虚拟共享内存的性能进行了测试，结果显示计算PDE程序和矩阵乘法程序的加速比几乎随处理器数量线性增长，而归并排序程序的加速比则增长不明显，但论文指出这和算法本身有很大关系。因此论文得出结论：松散耦合的多处理器上可以有效的实现虚拟共享内存机制。